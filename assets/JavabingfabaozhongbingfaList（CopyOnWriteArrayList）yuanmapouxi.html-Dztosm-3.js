import{_ as s,c as a,a as e,o as t}from"./app-B4ALHgv8.js";const p={};function l(i,n){return t(),a("div",null,n[0]||(n[0]=[e(`<p><strong>CopyOnWriteArrayList是J.U.C下的一个线程安全的ArrayList.</strong></p><h2 id="类图" tabindex="-1"><a class="header-anchor" href="#类图"><span>类图</span></a></h2><p><img src="https://img-blog.csdnimg.cn/7af73ff9e63c48abbdbefa6efd58d47a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGlyZWVr,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>除了RandomAccess，其他接口我相信大家都很熟悉，实现RandomAccess的标识list<strong>支持快速访问策略</strong>（for循环比iterator快）。</p><h2 id="public-e-set-int-index-e-element" tabindex="-1"><a class="header-anchor" href="#public-e-set-int-index-e-element"><span>public E set(int index, E element)</span></a></h2><p>增删改，我们就只看看修改这个方法，大同小异。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * Replaces the element at the specified position in this list with the</span>
<span class="line"> * specified element.</span>
<span class="line"> *</span>
<span class="line"> * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IndexOutOfBoundsException</span></span> <span class="token punctuation">{</span><span class="token keyword">@inheritDoc</span><span class="token punctuation">}</span></span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span></span>
<span class="line">    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!=</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// (1)</span></span>
<span class="line">            <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span></span>
<span class="line">            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            newElements<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span></span>
<span class="line">            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// Not quite a no-op; ensures volatile write semantics</span></span>
<span class="line">            <span class="token function">setArray</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (2)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码首先获取了<strong>独占锁</strong>（保证线程安全），从而阻止其他线程对array数组进行修改，然后获取当前数组，并调用get方法获取指定位置的元素，如果指定位置的元素值与新值不一致则创建新数组井复制元素，然后在新数组上修改指定位置的元素值并设置新数组到array。如果指定位置的元素值与新值一样，<strong>Not quite a no-op; ensures volatile write semantics</strong>，则为了保证volatile语义，还是需要重新设置array，虽然array的内容并没有改变。</p><p>想想volatile的语义，即可见性和内存屏障。具体见之前的第二章。我想应该是仅仅为了这个语义，因为是写操作。也可以参考：http://ifeve.com/copyonwritearraylist-set/</p><h2 id="写时复制策略产生的弱一致性问题" tabindex="-1"><a class="header-anchor" href="#写时复制策略产生的弱一致性问题"><span>写时复制策略产生的弱一致性问题</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * <span class="token punctuation">{</span><span class="token keyword">@inheritDoc</span><span class="token punctuation">}</span></span>
<span class="line"> *</span>
<span class="line"> * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IndexOutOfBoundsException</span></span> <span class="token punctuation">{</span><span class="token keyword">@inheritDoc</span><span class="token punctuation">}</span></span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>读是没有加任何锁的，读并不是一个原子操作。读的时候刚好还没修改完，由于修改的时候总是会拷贝一份进行修改，读的就是写之前的旧数据。这就是弱一致性问题。如果读操作对于实时性有特别高的要求，不建议使用。</p><p>内存占用问题，gc频繁回收，因为写操作总是拷贝数据，如果数组里的元素（对象）特别大，带来的垃圾回收的代价还是比较大的。</p><h2 id="与collections-synchronizedlist-new-arraylist-性能对比" tabindex="-1"><a class="header-anchor" href="#与collections-synchronizedlist-new-arraylist-性能对比"><span>与Collections.synchronizedList(new ArrayList()性能对比</span></a></h2><p>SynchronizedList加锁方式。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由加锁方式，写操作都是互斥锁实现，但是CopyOnWriteArrayList多了一个拷贝步骤。&lt;SynchronizedList。</p><p>而读又没有加锁，&gt;SynchronizedList。</p><p>所以，<strong>CopyOnWriteArrayList适合读多写少的场景，并且对数据的实时性要求不高。</strong></p><p>加油，期待蓝天的少年总抬头！</p>`,20)]))}const o=s(p,[["render",l]]),u=JSON.parse('{"path":"/blogs/shu/Javabingfabianchengzhimei/JavabingfabaozhongbingfaList（CopyOnWriteArrayList）yuanmapouxi.html","title":"Java并发包中并发List（CopyOnWriteArrayList）源码剖析","lang":"en-US","frontmatter":{"title":"Java并发包中并发List（CopyOnWriteArrayList）源码剖析","date":"2021-12-30T00:00:46.000Z","author":"Hireek","tags":["并发"],"categories":["Java并发编程之美"]},"headers":[{"level":2,"title":"类图","slug":"类图","link":"#类图","children":[]},{"level":2,"title":"public E set(int index, E element)","slug":"public-e-set-int-index-e-element","link":"#public-e-set-int-index-e-element","children":[]},{"level":2,"title":"写时复制策略产生的弱一致性问题","slug":"写时复制策略产生的弱一致性问题","link":"#写时复制策略产生的弱一致性问题","children":[]},{"level":2,"title":"与Collections.synchronizedList(new ArrayList()性能对比","slug":"与collections-synchronizedlist-new-arraylist-性能对比","link":"#与collections-synchronizedlist-new-arraylist-性能对比","children":[]}],"git":{},"filePathRelative":"blogs/书/Java并发编程之美/Java并发包中并发List（CopyOnWriteArrayList）源码剖析.md"}');export{o as comp,u as data};
